(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.RM = factory());
}(this, function () { 'use strict';

  function assertPath(path) {
    if (typeof path !== 'string') {
      throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
    }
  }

  // Resolves . and .. elements in a path with directory names
  function normalizeStringPosix(path, allowAboveRoot) {
    var res = '';
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i = 0; i <= path.length; ++i) {
      if (i < path.length) {
      code = path.charCodeAt(i);
      } else if (code === 47 /*/*/)
        break;
      else
        code = 47 /*/*/;

      if (code === 47 /*/*/) {
        if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf('/');
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = '';
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                }
                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = '';
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += '/..';
            else
              res = '..';
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += '/' + path.slice(lastSlash + 1, i);
          else
            res = path.slice(lastSlash + 1, i);
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === 46 /*.*/ && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }

  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep + base;
  }

  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
      var resolvedPath = '';
      var resolvedAbsolute = false;
      var cwd;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path;
        if (i >= 0)
          path = arguments[i];
        else {
          if (cwd === undefined) {
            // cwd = process.cwd();
            // 浏览器环境没有 process.cwd 方法
            cwd  = '/';
          }
          path = cwd;
        }

        assertPath(path);

        // Skip empty entries
        if (path.length === 0) {
          continue;
        }

        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
      }

      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)

      // Normalize the path
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return '/' + resolvedPath;
        else
          return '/';
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return '.';
      }
    },

    normalize: function normalize(path) {
      assertPath(path);

      if (path.length === 0) return '.';

      var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
      var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

      // Normalize the path
      path = normalizeStringPosix(path, !isAbsolute);

      if (path.length === 0 && !isAbsolute) path = '.';
      if (path.length > 0 && trailingSeparator) path += '/';

      if (isAbsolute) return '/' + path;
      return path;
    },

    isAbsolute: function isAbsolute(path) {
      assertPath(path);
      return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
    },

    join: function join() {
      if (arguments.length === 0)
        return '.';
      var joined;
      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments[i];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === undefined)
            joined = arg;
          else
            joined += '/' + arg;
        }
      }
      if (joined === undefined)
        return '.';
      return posix.normalize(joined);
    },

    relative: function relative(from, to) {
      assertPath(from);
      assertPath(to);

      if (from === to) return '';

      from = posix.resolve(from);
      to = posix.resolve(to);

      if (from === to) return '';

      // Trim any leading backslashes
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47 /*/*/)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;

      // Trim any leading backslashes
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47 /*/*/)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;

      // Compare paths to find the longest common path from root
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i = 0;
      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === 47 /*/*/) {
              // We get here if `from` is the exact base path for `to`.
              // For example: from='/foo/bar'; to='/foo/bar/baz'
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              // We get here if `from` is the root
              // For example: from='/'; to='/foo'
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
              // We get here if `to` is the exact base path for `from`.
              // For example: from='/foo/bar/baz'; to='/foo/bar'
              lastCommonSep = i;
            } else if (i === 0) {
              // We get here if `to` is the root.
              // For example: from='/foo'; to='/'
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i);
        var toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47 /*/*/)
          lastCommonSep = i;
      }

      var out = '';
      // Generate the relative path based on the path difference between `to`
      // and `from`
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
          if (out.length === 0)
            out += '..';
          else
            out += '/..';
        }
      }

      // Lastly, append the rest of the destination (`to`) path that comes after
      // the common path parts
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47 /*/*/)
          ++toStart;
        return to.slice(toStart);
      }
    },

    _makeLong: function _makeLong(path) {
      return path;
    },

    dirname: function dirname(path) {
      assertPath(path);
      if (path.length === 0) return '.';
      var code = path.charCodeAt(0);
      var hasRoot = code === 47 /*/*/;
      var end = -1;
      var matchedSlash = true;
      for (var i = path.length - 1; i >= 1; --i) {
        code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
          // We saw the first non-path separator
          matchedSlash = false;
        }
      }

      if (end === -1) return hasRoot ? '/' : '.';
      if (hasRoot && end === 1) return '//';
      return path.slice(0, end);
    },

    basename: function basename(path, ext) {
      if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
      assertPath(path);

      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;

      if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return '';
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47 /*/*/) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
            if (firstNonSlashEnd === -1) {
              // We saw the first non-path separator, remember this index in case
              // we need it if the extension ends up not matching
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              // Try to match the explicit extension
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  // We matched the extension, so mark this as the end of our path
                  // component
                  end = i;
                }
              } else {
                // Extension does not match, so our result is the entire path
                // component
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }

        if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
        return path.slice(start, end);
      } else {
        for (i = path.length - 1; i >= 0; --i) {
          if (path.charCodeAt(i) === 47 /*/*/) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
            // We saw the first non-path separator, mark this as the end of our
            // path component
            matchedSlash = false;
            end = i + 1;
          }
        }

        if (end === -1) return '';
        return path.slice(start, end);
      }
    },

    extname: function extname(path) {
      assertPath(path);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find
      var preDotState = 0;
      for (var i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46 /*.*/) {
            // If this is our first dot, mark it as the start of our extension
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 ||
          // We saw a non-dot character immediately before the dot
          preDotState === 0 ||
          // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return '';
      }
      return path.slice(startDot, end);
    },

    format: function format(pathObject) {
      if (pathObject === null || typeof pathObject !== 'object') {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format('/', pathObject);
    },

    parse: function parse(path) {
      assertPath(path);

      var ret = { root: '', dir: '', base: '', ext: '', name: '' };
      if (path.length === 0) return ret;
      var code = path.charCodeAt(0);
      var isAbsolute = code === 47 /*/*/;
      var start;
      if (isAbsolute) {
        ret.root = '/';
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i = path.length - 1;

      // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find
      var preDotState = 0;

      // Get non-dir info
      for (; i >= start; --i) {
        code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46 /*.*/) {
            // If this is our first dot, mark it as the start of our extension
            if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path.slice(1, startDot);
          ret.base = path.slice(1, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
      }

      if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

      return ret;
    },

    sep: '/',
    delimiter: ':',
    win32: null,
    posix: null
  };

  class Cache {
    constructor () {
      this.Modules = new Map();
    }

    cache (path, Module, update) {
      if (update || !this.has(path)) {
        this.Modules.set(path, Module);
      }
    }

    has (path) {
      return this.Modules.has(path)
    }

    get (path) {
      return this.Modules.get(path) || null
    }

    clear (path) {
      return this.Modules.delete(path)
    }

    clearAll () {
      return this.Modules.clear()
    }
  }

  var cache = new Cache();

  // if we don't recognize the path, we will eventually validate responseURL of xhr
  const responseURLModules = new Cache();

  // https://github.com/mozilla/source-map/blob/master/lib/base64-vlq.js
  // http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html
  const VLQ_BASE_SHIFT = 5;
  const VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  const VLQ_BASE_MASK = VLQ_BASE - 1;
  const VLQ_CONTINUATION_BIT = VLQ_BASE;
  const intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");

  function toVLQSigned (aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0
  }

  function base64Encode (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number]
    }
    throw new TypeError("Must be between 0 and 63: " + number)
  }

  // encode to VLQ
  function encoded (aValue) {
    let encoded = '';
    let digit;
    let vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64Encode(digit);
    } while (vlq > 0)

    return encoded
  }

  function genMappings (source) {
    const lines = source.split('\n');
    const code = l => encoded(0) + encoded(0) + encoded(l) + encoded(0);

    // the line is relative position,
    // so, current position relative to the previous line, only to +1
    return code(-1) + ';' + lines.map(v => code(1)).join(';')
  }

  function jsSourcemap (resource, responseURL) {
    const content = JSON.stringify({
      version: 3,
      sources: [responseURL],
      mappings: genMappings(resource),
    });
    return `//@ sourceMappingURL=data:application/json;base64,${btoa(content)}`
  }

  var config = {
    init: false,
    sourcemap: true,
    defaultExname: '.js',
  };

  const readOnly = (obj, key, value) => {
    Object.defineProperty(obj, key, {
      value: value,
      writable: false,
    });
  };

  const readOnlyMap = obj => {
    const newObj = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        readOnly(newObj, key, obj[key]);
      }
    }
    return newObj
  };

  const getLegalName = name => {
    if (!window[name]) return name
    return getLegalName(name + '1')
  };

  // export const realpath = path => {
  //   // /a/b/./c/./d ==> /a/b/c/d
  //   path = path.replace(DOT_RE, "/")

  //   /*
  //     a//b/c ==> a/b/c
  //     a///b/////c ==> a/b/c
  //   */
  //   path = path.replace(MULTI_SLASH_RE, "$1/")

  //   // a/b/c/../../d  ==>  a/b/../d  ==>  a/d
  //   while (path.match(DOUBLE_DOT_RE)) {
  //     path = path.replace(DOUBLE_DOT_RE, "/")
  //   }

  //   return path
  // }

  class Plugins {
    constructor (type) {
      this.type = type;
      this.plugins = new Set();
    }

    add (fn) {
      this.plugins.add(fn);
    }

    forEach (params) {
      let res = params;
      for (const plugin of this.plugins.values()) {
        res.resource = plugin(res);
      }
      return res
    }
  }

  const map = {
    allPlugins: new Map(),

    add (type, fn) {
      if (typeof type === 'string' && typeof fn === 'function') {
        if (!this.allPlugins.has(type)) {
          const pluginClass = new Plugins(type);
          pluginClass.add(fn);
          this.allPlugins.set(type, pluginClass);
        } else {
          this.allPlugins.get(type).add(fn);
        }
      } else {
        throw TypeError('The "parameter" does not meet the requirements')
      }
    },

    get (type = '*') {
      return this.allPlugins.get(type)
    },

    run (type, params) {
      const plugins = this.allPlugins.get(type);
      if (plugins) {
        return plugins.forEach(params)
      }
      return params
    }
  };

  // add default plugings
  function addDefaultPlugins () {
    map.add('*', opts => opts.resource);
    map.add('.js', jsPlugin);
  }

  function request (url, isAsync) {
    const getCache = xhr => {
      const responseURL = xhr.responseURL;
      if (responseURLModules.has(responseURL)) {
        // if we found cache module, abort request
        xhr.abort();
        return {
          responseURL,
          resource: null,
          haveCache: true,
        }
      }
      return null
    };

    const xhr = new XMLHttpRequest();
    xhr.open('GET', url, isAsync);
    xhr.send();

    if (isAsync) {
      return new Promise((resolve, reject) => {
        xhr.onreadystatechange = () => {
          const cache = getCache(xhr);
          cache && resolve({ target: cache });
        };

        xhr.onload = resolve;
        xhr.onerror = reject;
      })
    }

    return getCache(xhr) || xhr
  }

  function dealWithResponse (url, xhr, envPath) {
    if (xhr.haveCache) return xhr

    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        if (typeof xhr.response === 'string') {
          // return xhr infomation and resource
          return {
            resource: xhr.response,
            responseURL: xhr.responseURL,
          }
        }
      } else if (xhr.status === 404) {
        throw Error(`Module [${url}] not found.\n\n --> from [${envPath}]\n`)
      }
    }
  }

  async function asyncRequest (url, envPath) {
    const { target: xhr } = await request(url, true);
    return dealWithResponse(url, xhr, envPath)
  }

  function syncRequest (url, envPath) {
    const xhr = request(url, false);
    return dealWithResponse(url, xhr, envPath)
  }

  // inspect path
  const PROTOCOL = /\w+:\/\/?/g;
  let isStart = false;

  function init (opts = {}) {
    if (this.config && this.config.init) {
      throw new Error('Can\'t repeat init.')
    }

    opts.init = true;

    // set config attribute
    readOnly(this, 'config',
      readOnlyMap(Object.assign(config, opts))
    );

    return url => {
      if (!url || !posix.isAbsolute(url)) {
        throw Error('The startup path must be an absolute path.')
      }

      isStart = true;

      const parentConfig = {
        envDir: '/',
        envPath: url,
      };
      readOnly(this.config, 'entrance', url);
      addDefaultPlugins();
      importModule(url, parentConfig, this.config, true);
    }
  }

  function addPlugin (exname, fn) {
    if (this.config && this.config.init) {
      throw Error('Unable to add plugin after initialization.')
    } else {
      if (typeof exname === 'string') {
        const types = exname.split(' ');
        if (types.length) {
          if (types.length === 1) {
            map.add(types[0], fn);
          } else {
            for (const type of types) {
              map.add(type, fn);
            }
          }
        }
      }
    }
  }

  // load multiple modules
  function importAll (paths, parentInfo, config) {
    if (Array.isArray(paths)) {
      return Promise.all(
        paths.map(path => importModule(path, parentInfo, config, true))
      )
    }
    return importModule(path, parentInfo, config, true)
  }

  // deal with async or sync request and cache module
  function importModule (path, parentInfo, config, isAsync) {
    const envPath = parentInfo.envPath;
    if (!path || typeof path !== 'string') {
      throw TypeError(`Require path [${path}] must be a string. \n\n ---> from [${envPath}]\n`)
    }

    const pathOpts = getRealPath(path, parentInfo, config);
    // if aleady cache, return cache result
    if (cache.has(pathOpts.path)) {
      const Module = cache.get(pathOpts.path);
      const result = getModuleResult(Module);
      return !isAsync
        ? result
        : Promise.resolve(result)
    }

    return isAsync
      ? getModuleForAsync(pathOpts, config, envPath)
      : getModuleForSync(pathOpts, config, envPath)
  }

  // load module static resource
  function ready (paths) {
    const config = this.config;
    if (isStart) {
      throw Error('Static resources must be loaded before the module is loaded.')
    }
    if (!config || !config.init) {
      throw Error('This method must be called after initialization.')
    }
  }

  // jugement the path and make a deal
  function getRealPath (path, parentInfo, config) {
    if (path === '.' || path === './') {
      path = parentInfo.envPath;
    }

    let exname = posix.extname(path);
    if (!exname) {
      path += config.defaultExname;
      exname = config.defaultExname;
    }

    if (!posix.isAbsolute(path) && !PROTOCOL.test(path)) {
      path = posix.join(parentInfo.envDir, path);
    }

    return { path, exname }
  }

  function getModuleForAsync ({path, exname}, config, envPath) {
    return asyncRequest(path, envPath).then(res => {
      return processResource(path, exname, config, res)
    })
  }

  function getModuleForSync ({path, exname}, config, envPath) {
    const res = syncRequest(path, envPath);
    return processResource(path, exname, config, res)
  }

  function getModuleResult (Module) {
    return typeof Module === 'object' && Module.__rustleModule
      ? Module.exports
      : Module
  }

  // process resource
  function processResource (path, exname, config, {resource, responseURL}) {
    const Module = responseURLModules.has(responseURL)
      ? responseURLModules.get(responseURL)
      : runPlugins(exname, {
          path,
          exname,
          config,
          resource,
          responseURL,
        });
    
    // we need cache other Module
    cache.cache(path, Module);
    responseURLModules.cache(responseURL, Module);

    return getModuleResult(Module)
  }

  // use plugins
  function runPlugins (type, opts) {
    opts = map.run('*', opts);
    return map.run(type, opts).resource
  }

  function run (scriptCode, rigisterObject, windowModuleName) {
    // run script
    const node = document.createElement('script');
    node.text = scriptCode;

    window[windowModuleName] = rigisterObject;
    document.body.append(node);
    document.body.removeChild(node);

    delete window[windowModuleName];
  }

  function getRegisterParams (config, path, responseURL) {
    const Module = { exports: {} };

    // get current module pathname
    const envInfo = posix.parse(responseURL);
    const envDir = (new URL(envInfo.dir)).pathname;
    const parentInfo = {
      envDir,
      envPath: path,
    };

    readOnly(Module, '__rustleModule', true);

    // require methods
    const require = path => importModule(path, parentInfo, config, false);
    require.async = path => importModule(path, parentInfo, config, true);
    require.all = paths => importAll(paths, parentInfo, config);

    return {
      Module,
      require,
      dirname: envInfo.dir,
    }
  }

  // create a object, rigister to window
  function generateObject (config, path, responseURL) {
    const { dirname, Module, require } = getRegisterParams(config, path, responseURL);
    return {
      require,
      module: Module,
      __dirname: dirname,
      exports: Module.exports,
      __filename: responseURL,
    }
  }

  // create sciprt code
  function generateScriptCode (basecode, path, responseURL, parmas, config) {
    const randomId = Math.floor(Math.random() * 10000);
    const moduleName = getLegalName('__rustleModuleObject') + randomId;

    let scriptCode =
      `(function ${getLegalName(path.replace(/[\/.:]/g, '_'))} (${parmas.join(',')}) {` +
      `\n${basecode}` +
      `\n}).call(undefined, window.${moduleName}.${parmas.join(`,window.${moduleName}.`)});`;

    // generate soucemap
     if (config.sourcemap) {
      scriptCode += `\n${jsSourcemap(scriptCode, responseURL)}`;
    }

    return { moduleName, scriptCode }
  }

  function runInThisContext (code, path, responseURL, config) {
    const rigisterObject = generateObject(config, path, responseURL);
    const Module = rigisterObject.module;
    const parmas = Object.keys(rigisterObject);
    const { moduleName, scriptCode } = generateScriptCode(code, path, responseURL, parmas, config);

    // cache js module，because allow circulation import. like cjs
    cache.cache(path, Module);
    responseURLModules.cache(responseURL, Module);

    // run code
    run(scriptCode, rigisterObject, moduleName);

    // clear cache, because run script throw error
    cache.clear(path);
    return Module
  }

  function jsPlugin ({resource, path, config, responseURL}) {
    return runInThisContext(resource, path, responseURL, config)
  }

  var index = {
    init,
    path: posix,
    cache,
    ready,
    addPlugin,
    plugins: {
      jsPlugin,
      jsSourcemap,
    }
  };

  return index;

}));
