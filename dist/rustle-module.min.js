(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.RM = factory());
}(this, function () { 'use strict';

  var config = {
    init: false,
    defaultType: 'js',
  };

  const cacheModules = Object.create(null);

  function cacheModule (url, Module) {
    Object.defineProperty(cacheModules, url, {
      get () { return Module }
    });
  }

  function getModule (url) {
    return cacheModules[url]
  }

  const warn = (msg, isWarn) => {
    throw Error(msg)
  };

  const convertToReadOnly = obj => {
    const newObj = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        Object.defineProperty(newObj, key, {
          get () { return obj[key] }
        });
      }
    }
    return newObj
  };

  const getExname = path => {
    const index = path.lastIndexOf('.');
    return index > -1
      ? path.substr(index + 1)
      : null
  };

  function check (filepath, url) {
    if (filepath === url) {
      warn('can\'t import self.');
      return false
    }
    return true
  }

  function getRegisterParams (filepath, config) {
    const Module = { exports: {} };
    const require = url => {
      if (check(filepath, url)) {
        return importModule(url, config, false)
      }
    };
    const requireAsync = url => {
      if (check(filepath, url)) {
        return importModule(url, config, true)
      }
    };

    return { Module, require, requireAsync }
  }

  function run (code, url, config) {
    code = "'use strict';\n" + code;

    const { Module, require, requireAsync } = getRegisterParams(url, config);
    const fn = new Function('require', 'requireAsync', 'module', 'exports', '__filename', code);

    fn(require, requireAsync, Module, Module.exports, url);
    return Module
  }

  function request (url, async) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url, async);
    xhr.send();

    if (async) {
      return new Promise((resolve, reject) => {
        xhr.onload = resolve;
        xhr.onerror = reject;
      })
    }
    return xhr
  }

  function dealWithResponse (url, xhr, config) {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        if (typeof xhr.response === 'string') {
          return run(xhr.response, url, config)
        }
      } else if (xhr.status === 404) {
        throw Error(`${url} is not found.`)
      }
    }
  }

  async function asyncRequest (url, config) {
    const { target: xhr } = await request(url, true);
    return dealWithResponse(url, xhr, config)
  }

  function syncRequest (url, config) {
    const xhr = request(url, false);
    return dealWithResponse(url, xhr, config)
  }

  function init (url, otps = {}) {
    if (this.config && this.config.init) {
      warn('can\'t repeat init');
    }
    if (typeof url !== 'string') {
      warn('error');
    }

    otps.init = true;
    otps.baseURL = url;
    this.config = convertToReadOnly({...config, ...otps});
    
    importModule(url, this.config, true);
  }

  function importModule (url, config, isAsync) {
    if (typeof url !== 'string') {
      warn('url must be a string');
    }

    let exname = getExname(url);
    if (!exname) {
      exname = config.defaultType;
      url += ('.' + config.defaultType);
    }

    const Module = getModule(url);
    if (Module) {
      return isAsync
        ? Promise.resolve(Module.exports)
        : Module.exports
    }

    // 第一次获取走 xhr
    if (isAsync) {
      return asyncRequest(url, config).then(Module => {
        cacheModule(url, Module);
        return Module.exports
      })
    } else {
      const Module = syncRequest(url, config);
      cacheModule(url, Module);
      return Module.exports
    }
  }

  const rustleModule = {
    init,
  };

  return rustleModule;

}));
